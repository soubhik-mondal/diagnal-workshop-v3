"use strict";

/* The HTML parsing library based on jQuery */
const cheerio = require("cheerio");

/* Class representing the metadata scraping and parsing utility */
class Scraper {
  /**
   * Scrapes the html and collects all the metadata
   * @param  {string} url  The URL being scraped
   * @param  {string} html The HTML string being scraped
   * @return {object}      The metadata to be further processed
   */
  scrape(url, html) {
    try {
      /**
       * Represents the Cheerio object
       * @type {cheerio}
       */
      let $ = cheerio.load(html);

      /**
       * The basic output structure -
       *
       * "title" is taken from title tag (in case og:title is not found)
       * "type" is set to "website" (in case og:type is not found)
       * "url" simply contains the URL
       * "description" is populated from meta tag with name="description" (in case og:description is not found)
       * "raw" contains all the meta tags (similar to the Facebook tool at https://developers.facebook.com/tools/debug/)
       * "ogMetaData" contains only the og meta data for further processing
       *
       * @type {Object}
       */
      let output = {
        title: $("title").text(),
        type: "website",
        url: url,
        description: "",
        raw: [],
        ogMetaData: [],
      };

      /**
       * Select all meta tags
       */
      $("meta")
        /**
         * Convert to array
         */
        .toArray()
        /**
         * Map over the array and retrive only the attributes
         * "property" and "content" for og meta data
         * "name", etc. for other meta data
         */
        .map((each) => $(each).attr())

        /**
         * Loop over each element and organize the data
         */
        .forEach((elem) => {
          /**
           * An object containing all the attributes of the meta tag
           * @type {Object}
           */
          let rawData = {};

          /**
           * Converting from cheerio object to simple object
           */
          Object.keys(elem).forEach((each) => {
            rawData[each] = elem[each];
          });

          /**
           * Putting the meta tag data into "raw" array
           */
          output.raw.push(rawData);

          /**
           * If the meta tag contains og data then put it in "ogMetaData" array
           */
          if (elem.property && elem.property.startsWith("og")) {
            output.ogMetaData.push(rawData);
          }

          /**
           * If the meta tag is for description, then update the description
           */
          if (elem.name && elem.name === "description") {
            output.description = elem.content;
          }
        });

      /**
       * Return the output object
       */
      return output;
    } catch (error) {
      error.type = "cheerio"; // Setting type in case we want to track the source of the error later on
      throw error;
    }
  }

  /**
   * Parses the metadata generated by scrap method
   * and generates final output.
   *
   * The og properties and behavior are taken from https://ogp.me/
   *
   * @param  {object} metaData The output of scrap method
   * @return {object}          The final processed meta data object
   */
  parse(metaData) {
    metaData.ogMetaData.forEach((each) => {
      switch (each.property) {
        case "og:title":
          metaData.title = each.content;
          break;
        case "og:type":
          metaData.type = each.content;
          break;
        case "og:url":
          metaData.url = each.content;
          break;
        case "og:description":
          metaData.description = each.content;
          break;
        case "og:determiner":
          metaData.determiner = each.content;
          break;
        case "og:locale":
          metaData.locale = each.content;
          break;
        case "og:locale:alternate":
          /**
           * As there may be multiple og:locale:alternate tags,
           * we are pushing the data into an array. And also,
           * creating the array if it doesn't exist already.
           */
          if (metaData["locale:alternate"]) {
            metaData["locale:alternate"].push(each.content);
          } else {
            metaData["locale:alternate"] = [each.content];
          }
          break;
        case "og:site_name":
          metaData.site_name = each.content;
          break;
        case "og:image":
          /**
           * As there may be multiple og:image tags,
           * we are pushing the data into an array. And also,
           * creating the array if it doesn't exist already.
           *
           * We are treating the image as an object, as there may
           * be multiple sub-properties belonging to the image.
           */
          if (metaData.images) {
            metaData.images.push({
              url: each.content,
            });
          } else {
            metaData.images = [
              {
                url: each.content,
              },
            ];
          }
          break;
        case "og:image:secure_url":
          /**
           * If images array exist then attach this to the last image object,
           * otherwise ignore it.
           */
          if (metaData.images) {
            let lastImage = metaData.images.length - 1;
            metaData.images[lastImage].secure_url = each.content;
          }
          break;
        case "og:image:type":
          /**
           * If images array exist then attach this to the last image object,
           * otherwise ignore it.
           */
          if (metaData.images) {
            let lastImage = metaData.images.length - 1;
            metaData.images[lastImage].type = each.content;
          }
          break;
        case "og:image:width":
          /**
           * If images array exist then attach this to the last image object,
           * otherwise ignore it.
           */
          if (metaData.images) {
            let lastImage = metaData.images.length - 1;
            metaData.images[lastImage].width = each.content;
          }
          break;
        case "og:image:height":
          /**
           * If images array exist then attach this to the last image object,
           * otherwise ignore it.
           */
          if (metaData.images) {
            let lastImage = metaData.images.length - 1;
            metaData.images[lastImage].height = each.content;
          }
          break;
        case "og:image:alt":
          /**
           * If images array exist then attach this to the last image object,
           * otherwise ignore it.
           */
          if (metaData.images) {
            let lastImage = metaData.images.length - 1;
            metaData.images[lastImage].alt = each.content;
          }
          break;
        case "og:video":
          /**
           * As there may be multiple og:video tags,
           * we are pushing the data into an array. And also,
           * creating the array if it doesn't exist already.
           *
           * We are treating the video as an object, as there may
           * be multiple sub-properties belonging to the video.
           */
          if (metaData.videos) {
            metaData.videos.push({
              url: each.content,
            });
          } else {
            metaData.videos = [
              {
                url: each.content,
              },
            ];
          }
          break;
        case "og:video:secure_url":
          /**
           * If videos array exist then attach this to the last video object,
           * otherwise ignore it.
           */
          if (metaData.videos) {
            let lastVideo = metaData.videos.length - 1;
            metaData.videos[lastVideo].secure_url = each.content;
          }
          break;
        case "og:video:type":
          /**
           * If videos array exist then attach this to the last video object,
           * otherwise ignore it.
           */
          if (metaData.videos) {
            let lastVideo = metaData.videos.length - 1;
            metaData.videos[lastVideo].type = each.content;
          }
          break;
        case "og:video:width":
          /**
           * If videos array exist then attach this to the last video object,
           * otherwise ignore it.
           */
          if (metaData.videos) {
            let lastVideo = metaData.videos.length - 1;
            metaData.videos[lastVideo].width = each.content;
          }
          break;
        case "og:video:height":
          /**
           * If videos array exist then attach this to the last video object,
           * otherwise ignore it.
           */
          if (metaData.videos) {
            let lastVideo = metaData.videos.length - 1;
            metaData.videos[lastVideo].height = each.content;
          }
          break;
        case "og:video:alt":
          /**
           * If videos array exist then attach this to the last video object,
           * otherwise ignore it.
           */
          if (metaData.videos) {
            let lastVideo = metaData.videos.length - 1;
            metaData.videos[lastVideo].alt = each.content;
          }
          break;
        case "og:audio":
          /**
           * As there may be multiple og:audio tags,
           * we are pushing the data into an array. And also,
           * creating the array if it doesn't exist already.
           *
           * We are treating the audio as an object, as there may
           * be multiple sub-properties belonging to the audio.
           */
          if (metaData.audios) {
            metaData.audios.push({
              url: each.content,
            });
          } else {
            metaData.audios = [
              {
                url: each.content,
              },
            ];
          }
          break;
        case "og:audio:secure_url":
          /**
           * If audios array exist then attach this to the last audio object,
           * otherwise ignore it.
           */
          if (metaData.audios) {
            let lastAudio = metaData.audios.length - 1;
            metaData.audios[lastAudio].secure_url = each.content;
          }
          break;
        case "og:audio:type":
          /**
           * If audios array exist then attach this to the last audio object,
           * otherwise ignore it.
           */
          if (metaData.audios) {
            let lastAudio = metaData.audios.length - 1;
            metaData.audios[lastAudio].type = each.content;
          }
          break;
        case "og:audio:width":
          /**
           * If audios array exist then attach this to the last audio object,
           * otherwise ignore it.
           */
          if (metaData.audios) {
            let lastAudio = metaData.audios.length - 1;
            metaData.audios[lastAudio].width = each.content;
          }
          break;
        case "og:audio:height":
          /**
           * If audios array exist then attach this to the last audio object,
           * otherwise ignore it.
           */
          if (metaData.audios) {
            let lastAudio = metaData.audios.length - 1;
            metaData.audios[lastAudio].height = each.content;
          }
          break;
        case "og:audio:alt":
          /**
           * If audios array exist then attach this to the last audio object,
           * otherwise ignore it.
           */
          if (metaData.audios) {
            let lastAudio = metaData.audios.length - 1;
            metaData.audios[lastAudio].alt = each.content;
          }
          break;
      }
    });
    delete metaData.raw; // Deleting the raw meta tag data for now
    delete metaData.ogMetaData; // Deleting the raw og meta tag data for now
    return metaData;
  }
}

module.exports = Scraper;
